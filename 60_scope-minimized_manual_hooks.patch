From cdacec719fd83dc09d017c397dae67fdbba28d4c Mon Sep 17 00:00:00 2001
From: backslashxx <118538522+backslashxx@users.noreply.github.com>
Date: Thu, 12 Jun 2025 12:00:00 -0400
Subject: [PATCH] kernel_patches: scope-minimized manual hooks v1.4

-https://github.com/backslashxx/KernelSU/issues/5
-v1.4, multiple changes
__add walk_component for UL
__mark sucompat hooks as __attribute__((hot, always_inline))
____ksu_handle_execve_sucompat, ksu_handle_faccessat, ksu_handle_stat
____250612, edit: remove always_inline for old compiler compatibility.

-drop ksu_handle_compat_execve_ksud
__ref:
https://github.com/fatalcoder524/kernel_patches_additional/commit/719d8da1b48eaca5c56d4af158c6360fc9d15f49
https://github.com/Pzqqt/android_kernel_xiaomi_marble/commit/4b0b1b38c9371bf3d74a0fa4c39a00337a33ca7c
https://github.com/yamaizano/android_kernel_xiaomi_sdm660/commit/a0e84d6f8e1efa5e7a9e33f8a095d077d4f78427
---
 .../60_scope-minimized_manual_hooks.patch     | 149 ++++++++++++++++++
 1 file changed, 149 insertions(+)
 create mode 100644 kernel_patches/60_scope-minimized_manual_hooks.patch

diff --git a/kernel_patches/60_scope-minimized_manual_hooks.patch b/kernel_patches/60_scope-minimized_manual_hooks.patch
new file mode 100644
index 0000000..a16939b
--- /dev/null
+++ b/kernel_patches/60_scope-minimized_manual_hooks.patch
@@ -0,0 +1,149 @@
+diff --git a/drivers/input/input.c b/drivers/input/input.c
+index 78be582b5766..b2aaef083533 100644
+--- a/drivers/input/input.c
++++ b/drivers/input/input.c
+@@ -420,11 +420,21 @@ void input_handle_event(struct input_dev *dev,
+  * to 'seed' initial state of a switch or initial position of absolute
+  * axis, etc.
+  */
++#ifdef CONFIG_KSU
++extern bool ksu_input_hook __read_mostly;
++extern int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, int *value);
++#endif
++
+ void input_event(struct input_dev *dev,
+ 		 unsigned int type, unsigned int code, int value)
+ {
+ 	unsigned long flags;
+ 
++#ifdef CONFIG_KSU
++	if (unlikely(ksu_input_hook))
++		ksu_handle_input_handle_event(&type, &code, &value);
++#endif
++
+ 	if (is_event_supported(type, dev->evbit, EV_MAX)) {
+ 
+ 		spin_lock_irqsave(&dev->event_lock, flags);
+diff --git a/fs/exec.c b/fs/exec.c
+index 3fa0cd8dca6e..7c039608de44 100644
+--- a/fs/exec.c
++++ b/fs/exec.c
+@@ -2112,11 +2112,27 @@ void set_dumpable(struct mm_struct *mm, int value)
+ 	set_mask_bits(&mm->flags, MMF_DUMPABLE_MASK, value);
+ }
+ 
++#ifdef CONFIG_KSU
++extern bool ksu_execveat_hook __read_mostly;
++extern __attribute__((hot)) int ksu_handle_execve_sucompat(int *fd,
++			       const char __user **filename_user,
++			       void *__never_use_argv, void *__never_use_envp,
++			       int *__never_use_flags);
++extern int ksu_handle_execve_ksud(const char __user *filename_user,
++			const char __user *const __user *__argv);
++#endif
++
+ SYSCALL_DEFINE3(execve,
+ 		const char __user *, filename,
+ 		const char __user *const __user *, argv,
+ 		const char __user *const __user *, envp)
+ {
++#ifdef CONFIG_KSU
++	if (unlikely(ksu_execveat_hook))
++		ksu_handle_execve_ksud(filename, argv);
++	else
++		ksu_handle_execve_sucompat((int *)AT_FDCWD, &filename, NULL, NULL, NULL);
++#endif
+ 	return do_execve(getname(filename), argv, envp);
+ }
+ 
+@@ -2136,6 +2152,10 @@ COMPAT_SYSCALL_DEFINE3(execve, const char __user *, filename,
+ 	const compat_uptr_t __user *, argv,
+ 	const compat_uptr_t __user *, envp)
+ {
++#ifdef CONFIG_KSU // 32-bit su and 32-on-64 support
++	if (!ksu_execveat_hook)
++		ksu_handle_execve_sucompat((int *)AT_FDCWD, &filename, NULL, NULL, NULL);
++#endif
+ 	return compat_do_execve(getname(filename), argv, envp);
+ }
+ 
+diff --git a/fs/open.c b/fs/open.c
+index b1188f4a0a33..e32608312e04 100644
+--- a/fs/open.c
++++ b/fs/open.c
+@@ -502,8 +502,16 @@ static long do_faccessat(int dfd, const char __user *filename, int mode, int fla
+ 	return res;
+ }
+ 
++#ifdef CONFIG_KSU
++extern __attribute__((hot)) int ksu_handle_faccessat(int *dfd,
++			                    const char __user **filename_user, int *mode, int *flags);
++#endif
++
+ SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)
+ {
++#ifdef CONFIG_KSU
++	ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
++#endif
+ 	return do_faccessat(dfd, filename, mode, 0);
+ }
+ 
+diff --git a/fs/read_write.c b/fs/read_write.c
+index 7a2ff6157eda..ffacdfc5725d 100644
+--- a/fs/read_write.c
++++ b/fs/read_write.c
+@@ -618,8 +618,18 @@ ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)
+ 	return ret;
+ }
+ 
++#ifdef CONFIG_KSU
++extern bool ksu_vfs_read_hook __read_mostly;
++extern int ksu_handle_sys_read(unsigned int fd, char __user **buf_ptr,
++			size_t *count_ptr);
++#endif
++
+ SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)
+ {
++#ifdef CONFIG_KSU
++	if (unlikely(ksu_vfs_read_hook))
++		ksu_handle_sys_read(fd, &buf, &count);
++#endif
+ 	return ksys_read(fd, buf, count);
+ }
+ 
+diff --git a/fs/stat.c b/fs/stat.c
+index d57dd1cbe37c..8b95a0a4cd1b 100644
+--- a/fs/stat.c
++++ b/fs/stat.c
+@@ -471,6 +471,11 @@ SYSCALL_DEFINE2(newlstat, const char __user *, filename,
+ 	return cp_new_stat(&stat, statbuf);
+ }
+ 
++#ifdef CONFIG_KSU
++extern __attribute__((hot)) int ksu_handle_stat(int *dfd,
++			                    const char __user **filename_user, int *flags);
++#endif
++
+ #if !defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_SYS_NEWFSTATAT)
+ SYSCALL_DEFINE4(newfstatat, int, dfd, const char __user *, filename,
+ 		struct stat __user *, statbuf, int, flag)
+@@ -478,6 +483,9 @@ SYSCALL_DEFINE4(newfstatat, int, dfd, const char __user *, filename,
+ 	struct kstat stat;
+ 	int error;
+ 
++#ifdef CONFIG_KSU
++	ksu_handle_stat(&dfd, &filename, &flag);
++#endif
+ 	error = vfs_fstatat(dfd, filename, &stat, flag);
+ 	if (error)
+ 		return error;
+@@ -629,6 +637,9 @@ SYSCALL_DEFINE4(fstatat64, int, dfd, const char __user *, filename,
+ 	struct kstat stat;
+ 	int error;
+ 
++#ifdef CONFIG_KSU // 32-bit su
++	ksu_handle_stat(&dfd, &filename, &flag);
++#endif
+ 	error = vfs_fstatat(dfd, filename, &stat, flag);
+ 	if (error)
+ 		return error;
-- 
GitLab

